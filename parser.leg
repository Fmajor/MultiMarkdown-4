%{
/*

	parser.leg -> parser.c -- Parse (Multi)Markdown plain text for
		conversion into other formats
	
	(c) 2013 Fletcher T. Penney (http://fletcherpenney.net/).

	Derived from peg-multimarkdown, which was forked from peg-markdown,
	which is (c) 2008 John MacFarlane (jgm at berkeley dot edu), and 
	licensed under GNU GPL or MIT.

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License or the MIT
	license.  See LICENSE for details.
	
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
*/

#include "parser.h"
#include "writer.h"

#include <getopt.h>

/* Define shortcuts to adding nodes, etc. */
#define node(x)       mk_pos_node(x, NULL, thunk->begin, thunk->end)
#define str(x)        mk_pos_str(x, thunk->begin, thunk->end)
#define list(x,y)     mk_pos_list(x, y, thunk->begin, thunk->end)

#define ext(x)        extension(x,((parser_data *)G->data)->extensions)

#define YY_INPUT(buf, result, max_size, D) yy_input_func(buf, &result, max_size, (parser_data *)G->data)

/* redefine input buffer so that we draw from the specified source string 
	to make it thread/reentrant safe */
void yy_input_func(char *buf, int *result, int max_size, parser_data *data)
{                                                      \
	int yyc;                                           \
	if (data->charbuf && (*(data->charbuf) != '\0')) { \
		yyc = *(data->charbuf)++;                      \
	} else {                                           \
		yyc= EOF;                                      \
	}                                                  \
	(*result) = (EOF == yyc) ? 0 : (*(buf)= yyc, 1);   \
}

%}

Doc =  BOM? a:StartList b:StartList
	( &{ !ext(EXT_COMPATIBILITY) && !ext(EXT_NO_METADATA) }
		&( MetaDataKey Sp ':' Sp (!Newline)) MetaData
			{ a = cons($$, a); b = node(FOOTER); } )?
	( Block { a = cons($$, a); } )*
	BlankLine*	# TODO: Why do we need this when we didn't before? 
	{
		if (b!= NULL) a = cons(b,a);
		((parser_data *)G->data)->result = reverse(a);
	}

MetaData = a:StartList !([A-Za-z]+ "://") !SetextHeading
		(MetaDataKeyValue { a = cons($$, a); })+
		{ $$ = list(METADATA, a); }

MetaDataKeyValue = a:MetaDataKey Sp ':' Sp b:MetaDataValue
	{
		$$ = a;
		$$->children = b;
	}

MetaDataKey = < !([A-Za-z]+ "://") AlphanumericAscii ( Sp ( AlphanumericAscii | '_' | ' ' | '-' | '.' )+)* >
	{
		$$ = str(yytext);
		$$->key = METAKEY;
	}

SingleLineMetaKeyValue = MetaDataKey Sp ':' Sp (!Newline .)*

MetaDataValue = a:StartList
	((< (!Newline .)* > { a = cons(str(yytext), a); })
	((Newline &(!BlankLine !SingleLineMetaKeyValue Sp RawLine))
		{ a = cons(str("\n"), a); } | Newline)
	(!BlankLine !SingleLineMetaKeyValue Sp RawLine
		{ a = cons(str(yytext), a); } )* )
	{
		/* TODO: Need to grab start/stop range from the list */
		$$ = mk_str_from_list(a, false);
		$$->key = METAVALUE;
	}

Block =	BlankLine*
		( BlockQuote
		| Verbatim
		| &{ !ext(EXT_COMPATIBILITY) } DefinitionList
		| &{ !ext(EXT_COMPATIBILITY) } Glossary
		| Note
		| LinkReference
		| HorizontalRule
		| HeadingSection
		| OrderedList
		| BulletList
		| HtmlBlock
		| MarkdownHtmlBlock
		| StyleBlock
		| &{ !ext(EXT_COMPATIBILITY) } Table
		| &{ !ext(EXT_COMPATIBILITY) } ImageBlock
		| !(Sp? HtmlBlockOpenDiv) Para
		| Plain )

HeadingSectionBlock = BlankLine* !Heading
		( BlockQuote
		| Verbatim
		| &{ !ext(EXT_COMPATIBILITY) } DefinitionList
		| &{ !ext(EXT_COMPATIBILITY) } Glossary
		| Note
		| LinkReference
		| HorizontalRule
		| OrderedList
		| BulletList
		| HtmlBlock
		| MarkdownHtmlBlock
		| StyleBlock
		| &{ !ext(EXT_COMPATIBILITY) } Table
		| &{ !ext(EXT_COMPATIBILITY) } ImageBlock
		| !(Sp? HtmlBlockOpenDiv) Para
		| Plain )

Heading = SetextHeading | AtxHeading

HeadingSection = a:StartList Heading { a = cons($$, a); }
	(HeadingSectionBlock {a = cons($$, a); })*
	{ $$ = list(HEADINGSECTION, a); }

AtxInline = !Newline !( &{ !ext(EXT_COMPATIBILITY) } Sp AutoLabel Sp? '#'* Sp Newline) !(Sp? '#'* Sp Newline) Inline

AtxStart =  < ( "######" | "#####" | "####" | "###" | "##" | "#" ) >
		{ $$ = node(H1 + ((int)strlen(yytext) - 1)); }

AtxHeading = s:AtxStart Sp? a:StartList ( AtxInline { a = cons($$, a); } )+ ( Sp? b:AutoLabel { append_list(b,a);})? (Sp? '#'* Sp)? Sp < Newline >
# <newline> ensures that we count characters all the way to the end
		{ $$ = list(s->key,a); free(s); }

SetextHeading = SetextHeading1 | SetextHeading2

SetextBottom1 = '='+ Newline

SetextBottom2 = '-'+ Newline

SetextHeading1 =  &(RawLine SetextBottom1)
		a:StartList ( !Endline !( &{ !ext(EXT_COMPATIBILITY) } Sp AutoLabel ) Inline { a = cons($$, a); } )+ ( Sp b:AutoLabel { append_list(b,a);} Sp? )? Sp? Newline
		<SetextBottom1> { $$ = list(H1, a); }

SetextHeading2 =  &(RawLine SetextBottom2)
		a:StartList ( !Endline !( &{ !ext(EXT_COMPATIBILITY) } Sp AutoLabel ) Inline { a = cons($$, a); } )+ ( Sp b:AutoLabel { append_list(b,a)} Sp? )? Sp? Newline
		<SetextBottom2> { $$ = list(H2, a); }


BlockQuote = a:BlockQuoteRaw
	{ $$ = list(BLOCKQUOTE,a); }

BlockQuoteRaw =  a:StartList
		(( b:BlockQuoteMarker Line { a = cons($$, a); } )
		( !'>' !BlankLine Line { a = cons($$, a); } )*
		( BlankLine { a = cons(mk_str("\n"), a); } )*
		)+
		{
			$$ = b;
			node *raw;
			raw = mk_str_from_list(a, true);
			raw->key = RAW;
			$$->children = raw;
		}

BlockQuoteMarker = < ">" ' '? >
	{ $$ = str(yytext); $$->key = BLOCKQUOTEMARKER; }

BOM =			"\357\273\277"
Eof =			!.
Newline =		'\n' | '\r' '\n'?
Line =  RawLine
	{ $$ = str(yytext); }
RawLine =		( < (!'\r' !'\n' .)* Newline > | < .+ > Eof )
BlankLine =		Sp Newline
Sp =			Spacechar*
Spnl =          Sp (Newline Sp)?
Spacechar =		' ' | '\t'
Nonspacechar =  !Spacechar !Newline .
NormalChar =	!( SpecialChar | Spacechar | Newline ) .
SpecialChar =   '*' | '_' | '`' | '&' | '[' | ']' | '(' | ')' | '<' | '!' | '#' | '\\' | '\'' | '"' | ExtendedSpecialChar
ExtendedSpecialChar = &{ ext(EXT_SMART) } ('.' | '-' | '\'' | '"')
		| &{ ext(EXT_NOTES) } ( '^' )
		| &{ ext(EXT_CRITIC) } ( '{')

Quoted =        '"' (!'"' .)* '"' | '\'' (!'\'' .)* '\''
HtmlAttribute = (AlphanumericAscii | '-')+ Spnl ('=' Spnl (Quoted | (!'>' Nonspacechar)+))? Spnl
HtmlComment =   "<!--" (!"-->" .)* "-->"
HtmlTag =       '<' Spnl '/'? AlphanumericAscii+ Spnl HtmlAttribute* '/'? Spnl '>'


RawHtml =   < (HtmlComment | HtmlBlockScript | HtmlTag) >
	{
		if (ext(EXT_FILTER_HTML)) {
			$$ = list(LIST, NULL);
		} else {
			$$ = str(yytext);
			$$->key = HTML;
		}
	}

Alphanumeric = [0-9A-Za-z] | '\200' | '\201' | '\202' | '\203' | '\204' | '\205' | '\206' | '\207' | '\210' | '\211' | '\212' | '\213' | '\214' | '\215' | '\216' | '\217' | '\220' | '\221' | '\222' | '\223' | '\224' | '\225' | '\226' | '\227' | '\230' | '\231' | '\232' | '\233' | '\234' | '\235' | '\236' | '\237' | '\240' | '\241' | '\242' | '\243' | '\244' | '\245' | '\246' | '\247' | '\250' | '\251' | '\252' | '\253' | '\254' | '\255' | '\256' | '\257' | '\260' | '\261' | '\262' | '\263' | '\264' | '\265' | '\266' | '\267' | '\270' | '\271' | '\272' | '\273' | '\274' | '\275' | '\276' | '\277' | '\300' | '\301' | '\302' | '\303' | '\304' | '\305' | '\306' | '\307' | '\310' | '\311' | '\312' | '\313' | '\314' | '\315' | '\316' | '\317' | '\320' | '\321' | '\322' | '\323' | '\324' | '\325' | '\326' | '\327' | '\330' | '\331' | '\332' | '\333' | '\334' | '\335' | '\336' | '\337' | '\340' | '\341' | '\342' | '\343' | '\344' | '\345' | '\346' | '\347' | '\350' | '\351' | '\352' | '\353' | '\354' | '\355' | '\356' | '\357' | '\360' | '\361' | '\362' | '\363' | '\364' | '\365' | '\366' | '\367' | '\370' | '\371' | '\372' | '\373' | '\374' | '\375' | '\376' | '\377'
AlphanumericAscii = [A-Za-z0-9]
Digit = [0-9]

HexEntity =     < '&' '#' [Xx] [0-9a-fA-F]+ ';' >
DecEntity =     < '&' '#' [0-9]+ > ';' >
CharEntity =    < '&' [A-Za-z0-9]+ ';' >

NonindentSpace =    "   " | "  " | " " | ""
Indent =            "\t" | "    "
IndentedLine =      Indent Line
OptionallyIndentedLine = Indent? Line

Symbol = < SpecialChar >
		{ $$ = str(yytext); }

EscapedChar = '\\' !Newline < [-\\`|*_{}[\]()#+.!$><'""] >
		{ $$ = str(yytext); }

Entity = ( HexEntity | DecEntity | CharEntity )
		{ $$ = str(yytext); $$->key = HTML; }

Para =	NonindentSpace a:Inlines BlankLine+
		{ $$ = a; $$->key = PARA; }

Plain =	a:Inlines
		{ $$ = a; $$->key = PLAIN; }

Inlines =	a:StartList ( !Endline Inline { a = cons($$, a); }
			| c:Endline &Inline { a = cons(c, a); } )+ voidEndline?
		{ $$ = list(LIST, a); }

Inline = #&{ check_timeout((parser_data *)G->data) }
# TODO: the check_timeout function still slows us down -- do we still need it??
		&{ ext(EXT_CRITIC) } CriticMarkup
		| &{ !ext(EXT_COMPATIBILITY) } DollarMath
		| Str
		| &{ !ext(EXT_COMPATIBILITY) } MathSpan
		| Endline
		| UlOrStarLine
		| Space
		| Strong
		| Emph
		| &{ !ext(EXT_COMPATIBILITY) } CitationReference
		| Image
		| Link
		| NoteReference
		| Code
		| MarkdownHtmlTagOpen
		| RawHtml
		| Entity
		| EscapedChar
		| Smart
		| Symbol


Space = Spacechar+
	{ $$ = str(" "); $$->key = SPACE; }

Endline =   LineBreak | TerminalEndline | NormalEndline

NormalEndline =   Sp Newline !BlankLine !'>' !AtxStart
		!(Line ('='+ | '-'+) Newline)
		{
			$$ = str("\n");
			$$->key = SPACE; 
		}

TerminalEndline = Sp Newline Eof
		{ $$ = NULL; }

LineBreak = "  " a:NormalEndline
		{ $$ = a; $$->key = LINEBREAK; }

voidEndline = ("  " voidNormalEndline) | (Sp Newline Eof) | voidNormalEndline

voidNormalEndline = Sp Newline !BlankLine !'>' !AtxStart
		!(Line ('='+ | '-'+) Newline)

Str = 	a:StartList < NormalChar+ > { a = cons(str(yytext), a); }
		( StrChunk { a = cons($$, a); } )*
		{ if (a->next == NULL) { $$ = a; } else { $$ = list(LIST, a); } }

StrChunk = < (NormalChar | '_'+ &Alphanumeric)+ > { $$ = str(yytext); } |
	AposChunk

AposChunk = &{ ext(EXT_SMART) } '\'' &Alphanumeric
		{ $$ = node(APOSTROPHE); }

StartList = &.
	{ $$ = NULL; }

MathSpan = '\\' < (
	('\\[' (!'\\\\]' .)* '\\\\]') |
	('\\(' (!'\\\\)' .)* '\\\\)') ) >
{
	/* Basically, these delimiters indicate math in LaTeX syntax, and the
	   delimiters are compatible with MathJax and LaTeX
	   ASCIIMathML is *not* supported */
	$$ = str(yytext);
	$$->key = MATHSPAN;
}

DollarMathStart = '$' !(Spacechar | Newline)

DollarMathEnd = (!'\\' Nonspacechar) '$' !Nonspacechar

DollarMath = < DollarMathStart (!DollarMathEnd !Newline .)*  DollarMathEnd >
		{ $$ = str(yytext); $$->key = MATHSPAN; }

# This keeps the parser from getting bogged down on long strings of '*' or '_',
# or strings of '*' or '_' with space on each side:
UlOrStarLine =  (UlLine | StarLine) { $$ = str(yytext); }
StarLine =      < "****" '*'* > | < Spacechar '*'+ &Spacechar >
UlLine   =      < "____" '_'* > | < Spacechar '_'+ &Spacechar >

Emph =	EmphStar | EmphUl

Whitespace = Spacechar | Newline

EmphStar =  '*' !Whitespace
		a:StartList
		( !'*' b:Inline { a = cons(b, a); }
			| b:StrongStar  { a = cons(b, a); }
		)+
		<'*'>
		{ $$ = list(EMPH, a); }

EmphUl = '_' !Whitespace
		a:StartList
		( !'_' b:Inline { a = cons(b, a); }
			| b:StrongUl  { a = cons(b, a); }
		)+
		<'_'>
		{ $$ = list(EMPH, a); }

Strong = StrongStar | StrongUl

StrongStar = "**" !Whitespace
		a:StartList
		( !"**" b:Inline { a = cons(b, a); })+
		<"**">
		{ $$ = list(STRONG, a); }

StrongUl = "__" !Whitespace
		a:StartList
		( !"__" b:Inline { a = cons(b, a); })+
		<"__">
		{ $$ = list(STRONG, a); }

Link = ExplicitLink | ReferenceLink | AutoLink

ReferenceLink = ReferenceLinkDouble | ReferenceLinkSingle

ReferenceLinkDouble = ( a:Label < Spnl > !"[]" b:Label )
	{
		GString *text = g_string_new("");
		print_raw_node_tree(text, b->children);
		$$ = mk_link(a, text->str, NULL, NULL, NULL);
		g_string_free(text, TRUE);
		free_node_tree(b);
	}

ReferenceLinkSingle = ( a:Label < (Spnl "[]")? > )
	{
		$$ = mk_link(a, NULL, NULL, NULL, NULL);
		/* stash copy of raw source in case we need if */
		$$->str = strdup(yytext);
	}

CitationReference = CitationReferenceDouble | CitationReferenceSingle
	
CitationReferenceDouble = !"[]" a:Label < Spnl > !"[]" b:RawCitationReference
	{
		char *label;
		label = label_from_node_tree(a);
		$$ = mk_link(a, b->str, NULL, NULL, NULL);
		$$->key = CITATION;
		
		if (strcmp(label,"notcited") == 0)
			$$->key = NOCITATION;
		free(label);
		free_node_tree(b);
	}

CitationReferenceSingle =  < (( "[]" Spnl b:RawCitationReference )
		| ( b:RawCitationReference (Spnl "[]")? )) >
	{
		$$ = mk_link(NULL, b->str, NULL, NULL, NULL);
		$$->key = CITATION;
		free_node_tree(b);
	}

RawCitationReference = "[#" < ( !Newline !']' . )+ > ']'
		{ $$ = str(yytext); }

ExplicitLink = l:Label '(' Sp s:Source Spnl t:Title Sp <')'>
	{
		$$ = mk_link(l, NULL, s->str, t->str, NULL);
		free_node_tree(s);
		free_node_tree(t);
	}

Source = ( '<' < SourceContents > '>' | < SourceContents > )
	{ $$ = str(yytext); $$->key = SOURCE; }

SourceContents = ( ( !'(' !')' !'>' Nonspacechar )+ | '(' SourceContents ')')*

Title = ( TitleSingle | TitleDouble | < "" > )
	{ $$ = str(yytext); $$->key = TITLE; }

TitleSingle = '\'' < ( !( '\'' Sp ( ')' | Newline ) ) . )* > '\''

TitleDouble = '"' < ( !( '"' Sp ( ')' | Newline ) ) . )* > '"'

AutoLink = AutoLinkUrl | AutoLinkEmail

AutoLinkUrl =   '<' < [A-Za-z]+ "://" ( !Newline !'>' . )+ > '>'
	{
		$$ = mk_link(str(yytext), NULL, yytext, NULL, NULL);
	}

AutoLinkEmail = '<' ( "mailto:" )? < [-A-Za-z0-9+_./!%~$]+ '@' ( !Newline !'>' . )+ > '>'
	{
		char *mailto = malloc(strlen(yytext) + 8);
		sprintf(mailto, "mailto:%s", yytext);
		$$ = mk_link(str(yytext), NULL, mailto, NULL, NULL);
		free(mailto);
	}

LinkReference = a:StartList NonindentSpace !"[]" l:Label ':' Spnl s:RefSrc
		t:RefTitle
		( &{ !ext(EXT_COMPATIBILITY) } <Attributes { a = reverse($$); } )?>
		BlankLine+	# TODO: Can I get rid of this to allow sequential references?
		{ 
			/* Get label for referencing */
			GString *text = g_string_new("");
			char *clean;
			print_raw_node_tree(text, l->children);
			clean = clean_string(text->str);
			
			if (a == NULL) {
				/* no attributes */
				$$ = mk_link(NULL, clean, s->str, t->str, NULL);
			} else {
				$$ = mk_link(NULL, clean, s->str, t->str, a);
			}
			g_string_free(text, TRUE);
			free_node(s);
			free_node(t);
			free_node_tree(l);
			free(clean);
			$$->key = LINKREFERENCE;
		}


Attributes = a:StartList (Attribute { a = cons($$,a); })+
		{ $$ = a; }

Attribute = Spnl a:AttrKey '=' b:AttrValue
	{
		$$ = a;
		$$->children = b;
	}

AttrKey = < AlphanumericAscii+ >
	{
		char *lab;
		lab = label_from_string(yytext);
		$$ = mk_str(lab);
		$$->key = ATTRKEY;
		free(lab);
	}

AttrValue = (QuotedValue | UnQuotedValue)
		{ $$ = str(yytext); $$->key = ATTRVALUE; }

RefSrc = < Nonspacechar+ > 
		{ $$ = str(yytext); $$->key = HTML; }

RefTitle =  ( RefTitleSingle | RefTitleDouble | RefTitleParens | EmptyTitle )
		{ $$ = str(yytext); $$->key = RAW; }

EmptyTitle = < "" >

RefTitleSingle = Spnl '\'' < ( !( '\'' Sp Newline | Newline |
	&{ !ext(EXT_COMPATIBILITY) } '\'' Sp AlphanumericAscii+ '=' ) . )* > '\''

RefTitleDouble = Spnl '"' < ( !('"' Sp Newline | Newline |
	&{ !ext(EXT_COMPATIBILITY) } '"' Sp AlphanumericAscii+ '=' ) . )* > '"'

RefTitleParens = Spnl '(' < ( !(')' Sp Newline | Newline |
	&{ !ext(EXT_COMPATIBILITY) } ')' Sp AlphanumericAscii+ '=' ) . )* > ')'

QuotedValue = '"' < (!'"' .)* > '"'

UnQuotedValue = < (AlphanumericAscii | '.')+ >

ImageBlock = Image Sp Newline BlankLine+
	{ if ($$->key == IMAGE) $$->key = IMAGEBLOCK; }

Image = '!' ( !AutoLink Link )
		{ $$->key = IMAGE; }


Label = < "[" !'[' ( !'^' !'#' &{ ext(EXT_NOTES) } | &. &{ !ext(EXT_NOTES) } )
	a:StartList
		( !']' Inline { a = cons($$, a); } )*
			']'>
	{ $$ = list(LIST, a); }

AutoLabel = '[' < (!Newline !'^' !'#' . )( !Newline !']' . )+ > ']' &(!(Sp? ('(' | '[')))
{
	node *ref;
	$$ = str(yytext);
	$$->key = AUTOLABEL;
	
	/* And create a LINKREFERENCE so we can use it */
	char *label = label_from_string(yytext);
	GString *anchor = g_string_new(label);
	g_string_prepend(anchor, "#");
	ref = mk_link(NULL, label, anchor->str, NULL, NULL);

	g_string_free(anchor, true);
	free(label);
	((parser_data *)G->data)->autolabels = cons(ref,((parser_data *)G->data)->autolabels);
	ref->key = LINKREFERENCE;
}


# NoteReference = &{ ext(EXT_NOTES) } ( "[^" | "[#" ) < ( !Newline !']' . )+ > ']'
NoteReference = &{ ext(EXT_NOTES) } ( "[^" ) < ( !Newline !']' . )+ > ']'
		{ $$ = str(yytext); $$->key = NOTEREFERENCE; }

Glossary =  &{ ext(EXT_NOTES) }
		a:StartList
		NonindentSpace ref:RawNoteReference ':' Sp
		"glossary:" Sp (GlossaryTerm { a = cons($$, a); }) 
		(GlossarySortKey { a = cons($$, a); })?
		Newline
		( RawNoteBlock { a = cons($$, a); } )
		( &Indent RawNoteBlock { a = cons($$, a); } )*
		{
			node *label;
			label = str(ref->str);
			label->key = NOTELABEL;
			a = cons(label,a);
			$$ = list(GLOSSARYSOURCE, a);
			$$->str = strdup(ref->str);
			free_node(ref);
		}

GlossaryTerm =  < (!Newline !'(' .)+ >
	{ 
		$$ = mk_list(LIST, NULL);
		$$->str = 0;
		$$->children = mk_str(yytext);
		$$->key = GLOSSARYTERM;
	}

GlossarySortKey = '(' < (!')' !Newline .)* > ')'
	{ $$ = mk_str(yytext); $$->key = GLOSSARYSORTKEY; }

Ticks1 = "`" !'`'
Ticks2 = "``" !'`'
Ticks3 = "```" !'`'
Ticks4 = "````" !'`'
Ticks5 = "`````" !'`'

Code = ( Ticks1 Sp < ( ( !'`' Nonspacechar )+ | !Ticks1 '`'+ | !( Sp Ticks1 ) ( Spacechar | Newline !BlankLine ) )+ > Sp Ticks1
       | Ticks2 Sp < ( ( !'`' Nonspacechar )+ | !Ticks2 '`'+ | !( Sp Ticks2 ) ( Spacechar | Newline !BlankLine ) )+ > Sp Ticks2
       | Ticks3 Sp < ( ( !'`' Nonspacechar )+ | !Ticks3 '`'+ | !( Sp Ticks3 ) ( Spacechar | Newline !BlankLine ) )+ > Sp Ticks3
       | Ticks4 Sp < ( ( !'`' Nonspacechar )+ | !Ticks4 '`'+ | !( Sp Ticks4 ) ( Spacechar | Newline !BlankLine ) )+ > Sp Ticks4
       | Ticks5 Sp < ( ( !'`' Nonspacechar )+ | !Ticks5 '`'+ | !( Sp Ticks5 ) ( Spacechar | Newline !BlankLine ) )+ > Sp Ticks5
       )
       { $$ = str(yytext); $$->key = CODE; }

Smart = &{ ext(EXT_SMART) }
        ( Ellipsis | Dash | SingleQuoted | DoubleQuoted | Apostrophe )

Apostrophe = '\''
		{ $$ = node(APOSTROPHE); }

Ellipsis = ("..." | ". . .")
		{ $$ = node(ELLIPSIS); }

Dash = EmDash | EnDash

EnDash = < ( "--" | '-' &Digit) >
		{ $$ = str(yytext); $$->key = ENDASH; }

EmDash = ( <"---"> )
		{ $$ = str(yytext); $$->key = EMDASH; }


SingleQuoteStart = '\'' !(Spacechar | Newline)

SingleQuoteEnd = '\'' !Alphanumeric

SingleQuoted = SingleQuoteStart
		a:StartList
		( !SingleQuoteEnd b:Inline { a = cons(b, a); } )+
		SingleQuoteEnd
		{ $$ = mk_list(SINGLEQUOTED, a); }

DoubleQuoteStart = '"'

DoubleQuoteEnd = '"'

DoubleQuoted =  DoubleQuoteStart
		a:StartList
		( !DoubleQuoteEnd b:Inline { a = cons(b, a); } )+
		DoubleQuoteEnd
		{ $$ = mk_list(DOUBLEQUOTED, a); }


NonblankIndentedLine = !BlankLine IndentedLine

VerbatimChunk = a:StartList
		( BlankLine { a = cons(mk_str("\n"), a); } )*
		( NonblankIndentedLine { a = cons($$, a); } )+
		{ $$ = mk_str_from_list(a, false); }

Verbatim = BlankLine* a:StartList
		( VerbatimChunk { a = cons($$, a); } )+ BlankLine*
		{ $$ = mk_str_from_list(a, false); $$->key = VERBATIM; }


HorizontalRule = NonindentSpace
		( '*' Sp '*' Sp '*' (Sp '*')*
		| '-' Sp '-' Sp '-' (Sp '-')*
		| '_' Sp '_' Sp '_' (Sp '_')*)
		Sp Newline BlankLine+
		{ $$ = mk_node(HRULE); }

DefinitionList =  a:StartList &(TermLine+ Newline? NonindentSpace ':')
		( (Term { a = cons($$, a); } )+
			BlankLine?
			(Definition { a = cons($$, a);})+
			BlankLine*
		)+
		{ $$ = mk_list(LIST, a); $$->key = DEFLIST; }

TermLine = !':' !BlankLine (!Newline .)* Newline

Term =  a:StartList !BlankLine !':'
	(!Newline !Endline Inline {a = cons($$, a);} )+ Newline
	{ $$ = mk_list(TERM,a); }

Definition = (a:StartList b:StartList
		(BlankLine { b = cons(mk_str("\n"),b); } )?
		( NonindentSpace ':' Sp RawLine { a = cons(mk_str(yytext), a);}) 
		( !':' !BlankLine RawLine { a = cons(mk_str(yytext), a);})*
		( BlankLine {a = cons(mk_str("\n"),a);}
			(IndentedLine { a = cons(mk_str(yytext),a);})+ 
			{ a = cons(mk_str("\n"),a);}
		)*  )
		{
			if (b != NULL) { a = cons(b,a);}
			node *raw = mk_str_from_list(a, false);
			raw->key = RAW;
			$$ = list(DEFINITION,raw);
		}

Bullet = !HorizontalRule NonindentSpace ('+' | '*' | '-') Spacechar+

BulletList = &Bullet (ListTight | ListLoose)
		{ $$->key = BULLETLIST; }

ListTight = a:StartList
		( ListItemTight { a = cons($$, a); } )+
		BlankLine* !(Bullet | Enumerator)
		{ $$ = list(LIST, a); }

ListLoose = a:StartList
		( b:ListItem BlankLine*
		{
			node *li;
			li = b->children;
			li->str = realloc(li->str, strlen(li->str) + 3);
			strcat(li->str, "\n\n");  /* In loose list, \n\n added to end of each element */
			a = cons(b, a);
		} )+
		{ $$ = list(LIST, a); }

ListItem = < ( Bullet | Enumerator )>
		a:StartList
		ListBlock { a = cons($$, a); }
		( ListContinuationBlock { a = cons($$, a); } )*
		{
			node *raw;
			raw = mk_str_from_list(a, false);
			raw->key = RAW;
			$$ = node(LISTITEM);
			$$->children = raw;
		}

ListItemTight = ( Bullet | Enumerator )
		a:StartList
		ListBlock { a = cons($$, a); }
		( !BlankLine
		ListContinuationBlock { a = cons($$, a); } )*
		!ListContinuationBlock
		{
			node *raw;
			raw = mk_str_from_list(a, false);
			raw->key = RAW;
			$$ = node(LISTITEM);
			$$->children = raw;
		}

ListBlock = a:StartList
		!BlankLine Line { a = cons($$, a); }
		( ListBlockLine { a = cons($$, a); } )*
		{ $$ = mk_str_from_list(a, false); }

ListContinuationBlock = a:StartList
		( < BlankLine* >
		{
			if (strlen(yytext) == 0)
				a = cons(str("\001"), a); /* block separator */
			else
				a = cons(str(yytext), a);
		} )
		( Indent ListBlock { a = cons($$, a); } )+
		{  $$ = mk_str_from_list(a, false); }

Enumerator = NonindentSpace [0-9]+ '.' Spacechar+

OrderedList = &Enumerator (ListTight | ListLoose)
		{ $$->key = ORDEREDLIST; }

ListBlockLine = !BlankLine
		!( Indent? (Bullet | Enumerator) )
		!HorizontalRule
		OptionallyIndentedLine

# Parsers for different kinds of block-level HTML content.
# This is repetitive due to constraints of PEG grammar.

HtmlBlockOpenAddress = '<' Spnl ("address" | "ADDRESS") Spnl HtmlAttribute* '>'
HtmlBlockCloseAddress = '<' Spnl '/' ("address" | "ADDRESS") Spnl '>'
HtmlBlockAddress = HtmlBlockOpenAddress (HtmlBlockAddress | !HtmlBlockCloseAddress .)* HtmlBlockCloseAddress

HtmlBlockOpenArticle = '<' Spnl ("article" | "ARTICLE") Spnl HtmlAttribute* '>'
HtmlBlockCloseArticle = '<' Spnl '/' ("article" | "ARTICLE") Spnl '>'
HtmlBlockArticle = HtmlBlockOpenArticle (HtmlBlockArticle | !HtmlBlockCloseArticle .)* HtmlBlockCloseArticle

HtmlBlockOpenAside = '<' Spnl ("aside" | "ASIDE") Spnl HtmlAttribute* '>'
HtmlBlockCloseAside = '<' Spnl '/' ("aside" | "ASIDE") Spnl '>'
HtmlBlockAside = HtmlBlockOpenAside (HtmlBlockAside | !HtmlBlockCloseAside .)* HtmlBlockCloseAside

HtmlBlockOpenBlockquote = '<' Spnl ("blockquote" | "BLOCKQUOTE") Spnl HtmlAttribute* '>'
HtmlBlockCloseBlockquote = '<' Spnl '/' ("blockquote" | "BLOCKQUOTE") Spnl '>'
HtmlBlockBlockquote = HtmlBlockOpenBlockquote (HtmlBlockBlockquote | !HtmlBlockCloseBlockquote .)* HtmlBlockCloseBlockquote

HtmlBlockOpenCanvas = '<' Spnl ("canvas" | "CANVAS") Spnl HtmlAttribute* '>'
HtmlBlockCloseCanvas = '<' Spnl '/' ("canvas" | "CANVAS") Spnl '>'
HtmlBlockCanvas = HtmlBlockOpenCanvas (HtmlBlockCanvas | !HtmlBlockCloseCanvas .)* HtmlBlockCloseCanvas

HtmlBlockOpenCenter = '<' Spnl ("center" | "CENTER") Spnl HtmlAttribute* '>'
HtmlBlockCloseCenter = '<' Spnl '/' ("center" | "CENTER") Spnl '>'
HtmlBlockCenter = HtmlBlockOpenCenter (HtmlBlockCenter | !HtmlBlockCloseCenter .)* HtmlBlockCloseCenter

HtmlBlockOpenDir = '<' Spnl ("dir" | "DIR") Spnl HtmlAttribute* '>'
HtmlBlockCloseDir = '<' Spnl '/' ("dir" | "DIR") Spnl '>'
HtmlBlockDir = HtmlBlockOpenDir (HtmlBlockDir | !HtmlBlockCloseDir .)* HtmlBlockCloseDir

HtmlBlockOpenDiv = '<' Spnl ("div" | "DIV") Spnl HtmlAttribute* '>'
HtmlBlockCloseDiv = '<' Spnl '/' ("div" | "DIV") Spnl '>'
HtmlBlockDiv = HtmlBlockOpenDiv (HtmlBlockDiv | !HtmlBlockCloseDiv .)* HtmlBlockCloseDiv

HtmlBlockOpenDl = '<' Spnl ("dl" | "DL") Spnl HtmlAttribute* '>'
HtmlBlockCloseDl = '<' Spnl '/' ("dl" | "DL") Spnl '>'
HtmlBlockDl = HtmlBlockOpenDl (HtmlBlockDl | !HtmlBlockCloseDl .)* HtmlBlockCloseDl

HtmlBlockOpenFieldset = '<' Spnl ("fieldset" | "FIELDSET") Spnl HtmlAttribute* '>'
HtmlBlockCloseFieldset = '<' Spnl '/' ("fieldset" | "FIELDSET") Spnl '>'
HtmlBlockFieldset = HtmlBlockOpenFieldset (HtmlBlockFieldset | !HtmlBlockCloseFieldset .)* HtmlBlockCloseFieldset

HtmlBlockOpenFigure = '<' Spnl ("figure" | "FIGURE") Spnl HtmlAttribute* '>'
HtmlBlockCloseFigure = '<' Spnl '/' ("figure" | "FIGURE") Spnl '>'
HtmlBlockFigure = HtmlBlockOpenFigure (HtmlBlockFigure | !HtmlBlockCloseFigure .)* HtmlBlockCloseFigure

HtmlBlockOpenFooter = '<' Spnl ("footer" | "FOOTER") Spnl HtmlAttribute* '>'
HtmlBlockCloseFooter = '<' Spnl '/' ("footer" | "FOOTER") Spnl '>'
HtmlBlockFooter = HtmlBlockOpenFooter (HtmlBlockFooter | !HtmlBlockCloseFooter .)* HtmlBlockCloseFooter

HtmlBlockOpenForm = '<' Spnl ("form" | "FORM") Spnl HtmlAttribute* '>'
HtmlBlockCloseForm = '<' Spnl '/' ("form" | "FORM") Spnl '>'
HtmlBlockForm = HtmlBlockOpenForm (HtmlBlockForm | !HtmlBlockCloseForm .)* HtmlBlockCloseForm

HtmlBlockOpenHeader = '<' Spnl ("header" | "HEADER") Spnl HtmlAttribute* '>'
HtmlBlockCloseHeader = '<' Spnl '/' ("header" | "HEADER") Spnl '>'
HtmlBlockHeader = HtmlBlockOpenHeader (HtmlBlockHeader | !HtmlBlockCloseHeader .)* HtmlBlockCloseHeader

HtmlBlockOpenHgroup = '<' Spnl ("hgroup" | "HGROUP") Spnl HtmlAttribute* '>'
HtmlBlockCloseHgroup = '<' Spnl '/' ("hgroup" | "HGROUP") Spnl '>'
HtmlBlockHgroup = HtmlBlockOpenHgroup (HtmlBlockHgroup | !HtmlBlockCloseHgroup .)* HtmlBlockCloseHgroup

HtmlBlockOpenH1 = '<' Spnl ("h1" | "H1") Spnl HtmlAttribute* '>'
HtmlBlockCloseH1 = '<' Spnl '/' ("h1" | "H1") Spnl '>'
HtmlBlockH1 = HtmlBlockOpenH1 (HtmlBlockH1 | !HtmlBlockCloseH1 .)* HtmlBlockCloseH1

HtmlBlockOpenH2 = '<' Spnl ("h2" | "H2") Spnl HtmlAttribute* '>'
HtmlBlockCloseH2 = '<' Spnl '/' ("h2" | "H2") Spnl '>'
HtmlBlockH2 = HtmlBlockOpenH2 (HtmlBlockH2 | !HtmlBlockCloseH2 .)* HtmlBlockCloseH2

HtmlBlockOpenH3 = '<' Spnl ("h3" | "H3") Spnl HtmlAttribute* '>'
HtmlBlockCloseH3 = '<' Spnl '/' ("h3" | "H3") Spnl '>'
HtmlBlockH3 = HtmlBlockOpenH3 (HtmlBlockH3 | !HtmlBlockCloseH3 .)* HtmlBlockCloseH3

HtmlBlockOpenH4 = '<' Spnl ("h4" | "H4") Spnl HtmlAttribute* '>'
HtmlBlockCloseH4 = '<' Spnl '/' ("h4" | "H4") Spnl '>'
HtmlBlockH4 = HtmlBlockOpenH4 (HtmlBlockH4 | !HtmlBlockCloseH4 .)* HtmlBlockCloseH4

HtmlBlockOpenH5 = '<' Spnl ("h5" | "H5") Spnl HtmlAttribute* '>'
HtmlBlockCloseH5 = '<' Spnl '/' ("h5" | "H5") Spnl '>'
HtmlBlockH5 = HtmlBlockOpenH5 (HtmlBlockH5 | !HtmlBlockCloseH5 .)* HtmlBlockCloseH5

HtmlBlockOpenH6 = '<' Spnl ("h6" | "H6") Spnl HtmlAttribute* '>'
HtmlBlockCloseH6 = '<' Spnl '/' ("h6" | "H6") Spnl '>'
HtmlBlockH6 = HtmlBlockOpenH6 (HtmlBlockH6 | !HtmlBlockCloseH6 .)* HtmlBlockCloseH6

HtmlBlockOpenMenu = '<' Spnl ("menu" | "MENU") Spnl HtmlAttribute* '>'
HtmlBlockCloseMenu = '<' Spnl '/' ("menu" | "MENU") Spnl '>'
HtmlBlockMenu = HtmlBlockOpenMenu (HtmlBlockMenu | !HtmlBlockCloseMenu .)* HtmlBlockCloseMenu

HtmlBlockOpenNoframes = '<' Spnl ("noframes" | "NOFRAMES") Spnl HtmlAttribute* '>'
HtmlBlockCloseNoframes = '<' Spnl '/' ("noframes" | "NOFRAMES") Spnl '>'
HtmlBlockNoframes = HtmlBlockOpenNoframes (HtmlBlockNoframes | !HtmlBlockCloseNoframes .)* HtmlBlockCloseNoframes

HtmlBlockOpenNoscript = '<' Spnl ("noscript" | "NOSCRIPT") Spnl HtmlAttribute* '>'
HtmlBlockCloseNoscript = '<' Spnl '/' ("noscript" | "NOSCRIPT") Spnl '>'
HtmlBlockNoscript = HtmlBlockOpenNoscript (HtmlBlockNoscript | !HtmlBlockCloseNoscript .)* HtmlBlockCloseNoscript

HtmlBlockOpenOl = '<' Spnl ("ol" | "OL") Spnl HtmlAttribute* '>'
HtmlBlockCloseOl = '<' Spnl '/' ("ol" | "OL") Spnl '>'
HtmlBlockOl = HtmlBlockOpenOl (HtmlBlockOl | !HtmlBlockCloseOl .)* HtmlBlockCloseOl

HtmlBlockOpenP = '<' Spnl ("p" | "P") Spnl HtmlAttribute* '>'
HtmlBlockCloseP = '<' Spnl '/' ("p" | "P") Spnl '>'
HtmlBlockP = HtmlBlockOpenP (HtmlBlockP | !HtmlBlockCloseP .)* HtmlBlockCloseP

HtmlBlockOpenPre = '<' Spnl ("pre" | "PRE") Spnl HtmlAttribute* '>'
HtmlBlockClosePre = '<' Spnl '/' ("pre" | "PRE") Spnl '>'
HtmlBlockPre = HtmlBlockOpenPre (HtmlBlockPre | !HtmlBlockClosePre .)* HtmlBlockClosePre

HtmlBlockOpenProgress = '<' Spnl ("progress" | "PROGRESS") Spnl HtmlAttribute* '>'
HtmlBlockCloseProgress = '<' Spnl '/' ("progress" | "PROGRESS") Spnl '>'
HtmlBlockProgress = HtmlBlockOpenProgress (HtmlBlockProgress | !HtmlBlockCloseProgress .)* HtmlBlockCloseProgress

HtmlBlockOpenSection = '<' Spnl ("section" | "SECTION") Spnl HtmlAttribute* '>'
HtmlBlockCloseSection = '<' Spnl '/' ("section" | "SECTION") Spnl '>'
HtmlBlockSection = HtmlBlockOpenSection (HtmlBlockSection | !HtmlBlockCloseSection .)* HtmlBlockCloseSection

HtmlBlockOpenTable = '<' Spnl ("table" | "TABLE") Spnl HtmlAttribute* '>'
HtmlBlockCloseTable = '<' Spnl '/' ("table" | "TABLE") Spnl '>'
HtmlBlockTable = HtmlBlockOpenTable (HtmlBlockTable | !HtmlBlockCloseTable .)* HtmlBlockCloseTable

HtmlBlockOpenUl = '<' Spnl ("ul" | "UL") Spnl HtmlAttribute* '>'
HtmlBlockCloseUl = '<' Spnl '/' ("ul" | "UL") Spnl '>'
HtmlBlockUl = HtmlBlockOpenUl (HtmlBlockUl | !HtmlBlockCloseUl .)* HtmlBlockCloseUl

HtmlBlockOpenVideo = '<' Spnl ("video" | "VIDEO") Spnl HtmlAttribute* '>'
HtmlBlockCloseVideo = '<' Spnl '/' ("video" | "VIDEO") Spnl '>'
HtmlBlockVideo = HtmlBlockOpenVideo (HtmlBlockVideo | !HtmlBlockCloseVideo .)* HtmlBlockCloseVideo

HtmlBlockOpenDd = '<' Spnl ("dd" | "DD") Spnl HtmlAttribute* '>'
HtmlBlockCloseDd = '<' Spnl '/' ("dd" | "DD") Spnl '>'
HtmlBlockDd = HtmlBlockOpenDd (HtmlBlockDd | !HtmlBlockCloseDd .)* HtmlBlockCloseDd

HtmlBlockOpenDt = '<' Spnl ("dt" | "DT") Spnl HtmlAttribute* '>'
HtmlBlockCloseDt = '<' Spnl '/' ("dt" | "DT") Spnl '>'
HtmlBlockDt = HtmlBlockOpenDt (HtmlBlockDt | !HtmlBlockCloseDt .)* HtmlBlockCloseDt

HtmlBlockOpenFrameset = '<' Spnl ("frameset" | "FRAMESET") Spnl HtmlAttribute* '>'
HtmlBlockCloseFrameset = '<' Spnl '/' ("frameset" | "FRAMESET") Spnl '>'
HtmlBlockFrameset = HtmlBlockOpenFrameset (HtmlBlockFrameset | !HtmlBlockCloseFrameset .)* HtmlBlockCloseFrameset

HtmlBlockOpenLi = '<' Spnl ("li" | "LI") Spnl HtmlAttribute* '>'
HtmlBlockCloseLi = '<' Spnl '/' ("li" | "LI") Spnl '>'
HtmlBlockLi = HtmlBlockOpenLi (HtmlBlockLi | !HtmlBlockCloseLi .)* HtmlBlockCloseLi

HtmlBlockOpenTbody = '<' Spnl ("tbody" | "TBODY") Spnl HtmlAttribute* '>'
HtmlBlockCloseTbody = '<' Spnl '/' ("tbody" | "TBODY") Spnl '>'
HtmlBlockTbody = HtmlBlockOpenTbody (HtmlBlockTbody | !HtmlBlockCloseTbody .)* HtmlBlockCloseTbody

HtmlBlockOpenTd = '<' Spnl ("td" | "TD") Spnl HtmlAttribute* '>'
HtmlBlockCloseTd = '<' Spnl '/' ("td" | "TD") Spnl '>'
HtmlBlockTd = HtmlBlockOpenTd (HtmlBlockTd | !HtmlBlockCloseTd .)* HtmlBlockCloseTd

HtmlBlockOpenTfoot = '<' Spnl ("tfoot" | "TFOOT") Spnl HtmlAttribute* '>'
HtmlBlockCloseTfoot = '<' Spnl '/' ("tfoot" | "TFOOT") Spnl '>'
HtmlBlockTfoot = HtmlBlockOpenTfoot (HtmlBlockTfoot | !HtmlBlockCloseTfoot .)* HtmlBlockCloseTfoot

HtmlBlockOpenTh = '<' Spnl ("th" | "TH") Spnl HtmlAttribute* '>'
HtmlBlockCloseTh = '<' Spnl '/' ("th" | "TH") Spnl '>'
HtmlBlockTh = HtmlBlockOpenTh (HtmlBlockTh | !HtmlBlockCloseTh .)* HtmlBlockCloseTh

HtmlBlockOpenThead = '<' Spnl ("thead" | "THEAD") Spnl HtmlAttribute* '>'
HtmlBlockCloseThead = '<' Spnl '/' ("thead" | "THEAD") Spnl '>'
HtmlBlockThead = HtmlBlockOpenThead (HtmlBlockThead | !HtmlBlockCloseThead .)* HtmlBlockCloseThead

HtmlBlockOpenTr = '<' Spnl ("tr" | "TR") Spnl HtmlAttribute* '>'
HtmlBlockCloseTr = '<' Spnl '/' ("tr" | "TR") Spnl '>'
HtmlBlockTr = HtmlBlockOpenTr (HtmlBlockTr | !HtmlBlockCloseTr .)* HtmlBlockCloseTr

HtmlBlockOpenScript = '<' Spnl ("script" | "SCRIPT") Spnl HtmlAttribute* '>'
HtmlBlockCloseScript = '<' Spnl '/' ("script" | "SCRIPT") Spnl '>'
HtmlBlockScript = HtmlBlockOpenScript (!HtmlBlockCloseScript .)* HtmlBlockCloseScript


HtmlBlockInTags = HtmlBlockAddress
		| HtmlBlockArticle
		| HtmlBlockAside
		| HtmlBlockCanvas
		| HtmlBlockBlockquote
		| HtmlBlockCenter
		| HtmlBlockDir
		| HtmlBlockDiv
		| HtmlBlockDl
		| HtmlBlockFieldset
		| HtmlBlockFigure
		| HtmlBlockFooter
		| HtmlBlockForm
		| HtmlBlockHeader
		| HtmlBlockHgroup
		| HtmlBlockH1
		| HtmlBlockH2
		| HtmlBlockH3
		| HtmlBlockH4
		| HtmlBlockH5
		| HtmlBlockH6
		| HtmlBlockMenu
		| HtmlBlockNoframes
		| HtmlBlockNoscript
		| HtmlBlockOl
		| HtmlBlockP
		| HtmlBlockPre
		| HtmlBlockProgress
		| HtmlBlockSection
		| HtmlBlockTable
		| HtmlBlockUl
		| HtmlBlockVideo
		| HtmlBlockDd
		| HtmlBlockDt
		| HtmlBlockFrameset
		| HtmlBlockLi
		| HtmlBlockTbody
		| HtmlBlockTd
		| HtmlBlockTfoot
		| HtmlBlockTh
		| HtmlBlockThead
		| HtmlBlockTr
		| HtmlBlockScript

HtmlBlock = !MarkdownHtmlTagOpen < ( HtmlBlockInTags | HtmlComment | HtmlBlockSelfClosing ) >
		BlankLine+
		{
			if (ext(EXT_FILTER_HTML)) {
				$$ = mk_list(LIST, NULL);
			} else {
				$$ = str(yytext);
				if ( ext(EXT_PROCESS_HTML)) $$->key = RAW;
				else $$->key = HTMLBLOCK;
			}
		}

MarkdownHtmlBlock = &MarkdownHtmlTagOpen < ( HtmlBlockInTags | HtmlComment | HtmlBlockSelfClosing) >
		BlankLine+
		{ $$ = str(yytext); $$->key = RAW; }

MarkdownHtmlAttribute = ("markdown" | "MARKDOWN")
		Spnl '=' Spnl ('"' Spnl)? "1" (Spnl '"')? Spnl

MarkdownHtmlTagOpen = a:StartList '<' {a = cons(mk_str("<"),a);}
		Spnl <HtmlBlockType> {a = cons(mk_str(yytext),a);} Spnl
		(!MarkdownHtmlAttribute
			<HtmlAttribute> {a = cons(mk_str(" "),a);
				a = cons(mk_str(yytext),a);})*
			MarkdownHtmlAttribute
			(<HtmlAttribute> {a = cons(mk_str(" "),a);
				a = cons(mk_str(yytext),a);})*
			'>' { a = cons(mk_str(">"),a);}
			{ $$ = mk_str_from_list(a,false); $$->key = HTML; }

HtmlBlockSelfClosing = '<' Spnl HtmlBlockType Spnl HtmlAttribute* '/' Spnl '>'

HtmlBlockType = "address" | "blockquote" | "center" | "dir" | "div" | "dl" | "fieldset" | "form" | "h1" | "h2" | "h3" |
		"h4" | "h5" | "h6" | "hr" | "isindex" | "menu" | "noframes" | "noscript" | "ol" | "p" | "pre" | "table" |
		"ul" | "dd" | "dt" | "frameset" | "li" | "tbody" | "td" | "tfoot" | "th" | "thead" | "tr" | "script" |
		"ADDRESS" | "BLOCKQUOTE" | "CENTER" | "DIR" | "DIV" | "DL" | "FIELDSET" | "FORM" | "H1" | "H2" | "H3" |
		"H4" | "H5" | "H6" | "HR" | "ISINDEX" | "MENU" | "NOFRAMES" | "NOSCRIPT" | "OL" | "P" | "PRE" | "TABLE" |
		"UL" | "DD" | "DT" | "FRAMESET" | "LI" | "TBODY" | "TD" | "TFOOT" | "TH" | "THEAD" | "TR" | "SCRIPT"


StyleOpen   = '<' Spnl ("style" | "STYLE") Spnl HtmlAttribute* '>'
StyleClose  = '<' Spnl '/' ("style" | "STYLE") Spnl '>'
InStyleTags = StyleOpen (!StyleClose .)* StyleClose
StyleBlock  = < InStyleTags >
		BlankLine*
		{
			if (ext(EXT_FILTER_STYLES)) {
				$$ = mk_list(LIST, NULL);
			} else {
				$$ = mk_str(yytext);
				$$->key = HTMLBLOCK;
			}
		}


Table = a:StartList b:StartList (TableCaption { b = cons($$, b);})?
		TableBody { $$->key = TABLEHEAD; a = cons($$, a); }
		(SeparatorLine { append_list($$,a); } )
		(TableBody { a = cons($$, a);} )
		(BlankLine !TableCaption TableBody { a = cons($$, a); }
		&(TableCaption | BlankLine) )*
		( (TableCaption { b = cons($$, b);} &BlankLine) | &BlankLine)
		# Requires blank line to end table "block"
		{
			if (b != NULL) { append_list(b,a); };
			$$ = list(TABLE, a);
		}

TableBody = a:StartList (TableRow {a = cons($$, a);})+
		{ $$ = list(TABLEBODY, a);}

TableRow = a:StartList
		(!SeparatorLine &(TableLine)
		CellDivider?
		(TableCell { a = cons($$, a); })+ ) Sp <Newline>
		{ $$ = list(TABLEROW, a); }

TableLine = (!Newline !CellDivider .)* CellDivider

TableCell = ExtendedCell | EmptyCell | FullCell

ExtendedCell = (EmptyCell | FullCell) <CellDivider+>
	{
		node *span;
		span = str(yytext);
		span->key = CELLSPAN;
		span->next = $$->children;
		$$->children = span;
    }


CellStr = < (!CellDivider NormalChar) (!CellDivider NormalChar | '_'+ &Alphanumeric)* >
		{ $$ = str(yytext); }


FullCell = Sp a:StartList  ((!CellDivider CellStr | !Newline !Endline !CellDivider !Str !(Sp &CellDivider) Inline ) { a = cons($$,a)})+
    <Sp> ( CellDivider )?
		{ $$ = list(TABLECELL,a); }

EmptyCell = <Sp> CellDivider
		{ $$ = node(TABLECELL); }

SeparatorLine = a:StartList 
		&(TableLine)
		CellDivider?
		( AlignmentCell { a = cons($$, a);})+ Sp Newline
		{
			$$ = mk_str_from_list(a,false);
			$$->key = TABLESEPARATOR;
		}

AlignmentCell = Sp (!CellDivider ( LeftAlignWrap | CenterAlignWrap | RightAlignWrap | LeftAlign | CenterAlign | RightAlign))
		Sp ( CellDivider )?

LeftAlignWrap = ':'? '-'+ '+' &(!'-' !':')
		{ $$ = mk_str("L");}

LeftAlign = ':'? '-'+ &(!'-' !':')
		{ $$ = mk_str("l");}

CenterAlignWrap = ':' '-'* '+' ':' &(!'-' !':')
		{ $$ = mk_str("C");}

CenterAlign = ':' '-'* ':' &(!'-' !':')
		{ $$ = mk_str("c");}

RightAlignWrap = '-'+ ':' '+' &(!'-' !':')
		{ $$ = mk_str("R");}

RightAlign = '-'+ ':' &(!'-' !':')
		{ $$ = mk_str("r");}

CellDivider = '|'

TableCaption = b:StartList a:Label
		( c:AutoLabel { b = c; b->key = TABLELABEL;})? Sp Newline
		{
			$$ = a;
			$$->key = TABLECAPTION;
			if ( (b != NULL) && (b->key == TABLELABEL) ) {
				b->next = $$->children;
				$$->children = b;
			}
		}

RawNoteReference = ( "[^" | "[#" ) < ( !Newline !']' . )+ > ']'
		{ $$ = str(yytext); }

Note = &{ ext(EXT_NOTES) }
		NonindentSpace ref:RawNoteReference ':' Sp
		a:StartList
		( RawNoteBlock { a = cons($$, a); } )
		( &Indent RawNoteBlock { a = cons($$, a); } )*
		{
			node *label;
			label = str(ref->str);
			label->key = NOTELABEL;
			a = cons(label,a);
			$$ = list(NOTESOURCE, a);
			$$->str = strdup(ref->str);
			
			free_node(ref);
		}

RawNoteBlock = a:StartList
		( !BlankLine !(NonindentSpace RawNoteReference) OptionallyIndentedLine { a = cons($$, a); } )+
		( < BlankLine* > { a = cons(str(yytext), a); } )
		{ $$ = mk_str_from_list(a, true); $$->key = RAW; }

DocForOPML = BOM? a:StartList 
		( &{ !ext(EXT_COMPATIBILITY) }
		&( MetaDataKey Sp ':' Sp (!Newline)) MetaData { a = cons($$, a); })?
		( OPMLBlock { a = cons($$, a); } )*
		BlankLine*	# TODO: Why do we need this when we didn't before? 
		{ ((parser_data *)G->data)->result = reverse(a); }

OPMLBlock = BlankLine* ( OPMLHeadingSection | OPMLPlain )

OPMLHeadingSection = a:StartList OPMLHeading { a = cons($$, a); }
		(OPMLSectionBlock {a = cons($$, a); })*
		{ $$ = mk_list(HEADINGSECTION, a);}

OPMLHeading = OPMLAtxHeading | OPMLSetextHeading

OPMLAtxHeading = &(Heading) s:AtxStart Sp? 
		< (!Newline !(Sp? '#'* Sp Newline) .)* > 
		(Sp? '#'+)? Sp? Newline
		{
			$$ = str(yytext);
			$$->key = s->key;
			free_node(s);
		}

OPMLSetextHeading = OPMLSetextHeading1 | OPMLSetextHeading2

OPMLSetextHeading1 = < (!'\r' !'\n' .)* > Newline SetextBottom1 
		{ $$ = str(yytext); $$->key = H1; }

OPMLSetextHeading2 = < (!'\r' !'\n' .)* > Newline SetextBottom2
		{ $$ = str(yytext); $$->key = H2; }

OPMLSectionBlock = BlankLine* !OPMLHeading OPMLPlain

OPMLPlain = a:StartList (!BlankLine !Heading Line { a = cons($$,a); })+
		{ $$ = mk_list(PLAIN, a); }

# Critic Markup

CriticMarkup = CriticAddition | CriticDeletion | CriticSubstitution | CriticHighlight | CriticComment

CriticAddition = ('{++' < (!'++}' .)* > '++}')
	{ $$ = str(yytext); $$->key = CRITICADDITION; }

CriticDeletion = ('{--' < (!'--}' .)* > '--}')
	{ $$ = str(yytext); $$->key = CRITICDELETION; }

CriticSubstitution = a:StartList ( '{~~' CriticSubstDel { a = cons($$,a); } '~>' CriticSubstAdd { a = cons($$,a); } '~~}')
	{ $$ = list(CRITICSUBSTITUTION, a); }

CriticSubstDel = < (!'~>' .)* >
	{ $$ = str(yytext); $$->key = CRITICDELETION; }

CriticSubstAdd = < (!'~~}' .)* >
	{ $$ = str(yytext); $$->key = CRITICADDITION; }

CriticHighlight = ('{==' < (!'==}' .)* > '==}')
	{ $$ = str(yytext); $$->key = CRITICHIGHLIGHT; }

CriticComment = ('{>>' < (!'<<}' .)* > '<<}')
	{ $$ = str(yytext); $$->key = CRITICCOMMENT; }

DocForCritic = BOM? a:StartList
		( CriticString { a = cons($$, a); } | RawString { a = cons($$, a); } )*
		( RawString { a = cons($$, a); } )* Eof
		{ ((parser_data *)G->data)->result = reverse(a); }

CriticString = CriticMarkup

RawString = < (!( "{++" | "{--" | "{~~" | "{==" | "{>>" ) .)+ >
		{ $$ = str(yytext); }

%%

/* process_raw_blocks -- follow the tree and process any RAW nodes and insert them
	into the tree */
node * process_raw_blocks(node * n, int extensions) {
	/* from the parser data we get the parent node and pointer to reference list */
	node *current = NULL;
	node *last_child = NULL;
	char *contents;
	GREG g;

	current = n;
	
	while (current != NULL) {
		if (current->key == RAW) {
			/* Process this RAW block */
			
			yyinit(&g);
			contents = strtok(current->str, "\001");
			current->key = LIST;
			g.data = mk_parser_data(contents, (extensions | EXT_NO_METADATA ));
			
			while (yyparse(&g));
			
			current->children = ((parser_data *)g.data)->result;
			
			free((parser_data *)g.data);	/* we're not using free_parser_data to preserve result tree */
			
			yydeinit(&g);
			
			last_child = current->children;
			while ((contents = strtok(NULL, "\001"))) {
				while (last_child->next != NULL) 
					last_child = last_child->next;
					
					yyinit(&g);
					g.data = mk_parser_data(contents, (extensions | EXT_NO_METADATA ));
					while (yyparse(&g));
					last_child->next = ((parser_data *)g.data)->result;
					free((parser_data *)g.data);
					yydeinit(&g);
			}
			free(current->str);
			current->str = NULL;
		}
		if (current->children != NULL) {
			/* Recurse into children */
			current->children = process_raw_blocks(current->children, extensions);
		}
		current = current->next;
	}
	return n;
}

char * markdown_to_string(char * source, int extensions, int format) {
	char *out;
	char *formatted;
	char *critic_resolved;
	node *refined;
	GREG g;               /* create parser context */
	yyinit(&g);

	/* Resolve Critic Markup before parsing */
	if ((extensions & EXT_CRITIC_ACCEPT) || (extensions & EXT_CRITIC_REJECT)) {
		g.data = mk_parser_data(source, extensions);

		while (yyparse_from(&g, yy_DocForCritic));
		
		if (extensions & EXT_CRITIC_REJECT) {
			if ((extensions & EXT_CRITIC_ACCEPT) && (format == HTML_FORMAT))
				critic_resolved = export_node_tree(((parser_data *)g.data)->result, CRITIC_HTML_HIGHLIGHT_FORMAT, extensions);
			else
				critic_resolved = export_node_tree(((parser_data *)g.data)->result, CRITIC_REJECT_FORMAT, extensions);
		} else {
			critic_resolved = export_node_tree(((parser_data *)g.data)->result, CRITIC_ACCEPT_FORMAT , extensions);
		}
		
		free_parser_data((parser_data *)g.data);
		yydeinit(&g);
		yyinit(&g);

		formatted = preformat_text(critic_resolved);
		free(critic_resolved);
	} else {
		formatted = preformat_text(source);
	}
	
	g.data = mk_parser_data(formatted,extensions);
	
	if (format == OPML_FORMAT) {
		while (yyparse_from(&g, yy_DocForOPML));	/* We want simpler version */
	} else {
		while (yyparse(&g));       /* parse */
	}

	if (((parser_data *)g.data)->parse_aborted) {
		/* clean up */
		free_parser_data((parser_data *)g.data);
		yydeinit(&g);
		
		free(formatted);
		
		out = strdup("MultiMarkdown was unable to parse this file.");
		return out;
	}

	refined = process_raw_blocks(((parser_data *)g.data)->result, extensions);    /* iteratively parse RAW bits */

	/* move autolabels to main parse tree */
	if (((parser_data *)g.data)->autolabels != NULL) {
//		fprintf(stderr, "We have autolabels\n");
		append_list(((parser_data *)g.data)->autolabels,refined);
		((parser_data *)g.data)->autolabels = NULL;	
	} else {
//		fprintf(stderr, "No autolabels\n");
	}
	
	/* Show what we got */
	out = export_node_tree(refined, format, extensions);
	
	/* clean up */
	free_parser_data((parser_data *)g.data);
	yydeinit(&g);
	
	free(formatted);
	return out;
}

/* has_metadata -- determine whether metadata exists or not */
bool has_metadata(char *source, int extensions) {
    char *formatted;
    GREG g;
    yyinit(&g);
    node *result;
    bool answer = FALSE;
    
    formatted = preformat_text(source);
    g.data = mk_parser_data(formatted, extensions);
    
    /* TODO: change this to parse only the metadata for speed */
    while (yyparse(&g));

    result = ((parser_data *)g.data)->result;

    if ((result != NULL) && (result->key == METADATA)) {
		answer = TRUE;
    }

	free_parser_data((parser_data *)g.data);
	yydeinit(&g);
	
	free(formatted);
	return answer;
}

/* extract_metadata_value -- find the value and return it */
char * extract_metadata_value(char *source, int extensions, char *key) {
	char *out;
	char *formatted;
	GREG g;
	yyinit(&g);
	
	/* don't preformat if doing syntax highlighting */
	formatted = preformat_text(source);
	g.data = mk_parser_data(formatted,extensions);
	
	while (yyparse(&g));       /* parse */

	if (((parser_data *)g.data)->parse_aborted) {
		out = strdup("MultiMarkdown was unable to parse this file.");
	} else {
		out = metavalue_for_key(key,((parser_data *)g.data)->result);
	}
	
	
	free_parser_data((parser_data *)g.data);
	yydeinit(&g);
	
	free(formatted);
	return out;
}

#ifndef MMD_LIBRARY

int main(int argc, char **argv)
{
	int numargs;
	int c;
	int i;
	static int batch_flag = 0;
	static int complete_flag = 0;
	static int compatibility_flag = 0;
	static int notes_flag = 0;
	static int no_notes_flag = 0;
	static int typography_flag = 0;
	static int no_typography_flag = 0;
	static int label_flag = 0;
	static int no_label_flag = 0;
	static int obfuscate_flag = 0;
	static int no_obfuscate_flag = 0;
	static int process_html_flag = 0;
	char *target_meta_key = FALSE;
		
	static struct option long_options[] = {
		{"batch", no_argument, &batch_flag, 1},                    /* process each file separately */
		{"to", required_argument, 0, 't'},                         /* which output format to use */
		{"full", no_argument, &complete_flag, 1},                  /* complete document */
		{"output", required_argument, 0, 'o'},                     /* which output format to use */
		{"notes", no_argument, &notes_flag, 1},                    /* use footnotes */
		{"nonotes", no_argument, &no_notes_flag, 1},               /* don't use footnotes */
		{"smart", no_argument, &typography_flag, 1},               /* use smart typography */
		{"nosmart", no_argument, &no_typography_flag, 1},          /* don't use smart typography */
		{"mask", no_argument, &obfuscate_flag, 1},                 /* mask email addresses */
		{"nomask", no_argument, &no_obfuscate_flag, 1},            /* don't mask email addresses */
		{"labels", no_argument, &label_flag, 1},                   /* generate labels */
		{"nolabels", no_argument, &no_label_flag, 1},              /* don't generate labels */
		{"compatibility", no_argument, &compatibility_flag, 1},    /* compatibility mode */
		{"process-html", no_argument, &process_html_flag, 1},      /* process Markdown inside HTML */
		{"accept", no_argument, 0, 'a'},                           /* Accept all proposed CriticMarkup changes */
		{"reject", no_argument, 0, 'r'},                           /* Reject all proposed CriticMarkup changes */
		{"extract", required_argument, 0, 'e'},                    /* show value of specified metadata */
		{"version", no_argument, 0, 'v'},                          /* display version information */
		{"help", no_argument, 0, 'h'},                             /* display usage information */
		{NULL, 0, NULL, 0}
	};
	
	GString *inputbuf;
	FILE *input;
	FILE *output;
	int curchar;
	GString *filename = NULL;
	char *temp;
	
	char *out;
	
	/* set up my data for the parser */
	int output_format = 0;
	int extensions = 0;
	extensions = extensions | EXT_SMART | EXT_NOTES | EXT_OBFUSCATE;
	
	/* process options */
	while (1) {
		int option_index = 0;

		c = getopt_long (argc, argv, "vhco:bft:e:ar", long_options, &option_index);
		
		if (c == -1)
			break;
		
		switch (c) {
			case 0: /* handle long_options */
				/* printf ("option %s", long_options[option_index].name);
				if (optarg)
				printf (" with arg %s", optarg);
				printf("\n"); */
				break;
			
			case 'b':	/* batch */
				batch_flag = 1;
				break;
			
			case 'c':	/* compatibility */
				compatibility_flag = 1;
				break;
			
			case 'o':	/* output filename */
				if (optarg)
					filename = g_string_new(optarg);
				break;
			
			case 'v':	/* show version */
				printf("\nMultiMarkdown version %s\n%s\n",MMD_VERSION, MMD_COPYRIGHT);
				return(EXIT_SUCCESS);

			case 'h':	/* show usage */
				printf("\nMultiMarkdown version %s\n\n",MMD_VERSION);
				printf("    %s  [OPTION...] [FILE...]\n",argv[0]);
				printf("\n"
				"    Options:\n"
				"    -h, --help             Show help\n"
				"    -v, --version          Show version information\n"
				"    -o, --output=FILE      Send output to FILE\n"
				"    -t, --to=FORMAT        Convert to FORMAT\n"
				"    -b, --batch            Process each file separately\n"
				"    -c, --compatibility    Markdown compatibility mode\n"
				"    -f, --full             Force a complete document\n"
				"    --process-html         Process Markdown inside of raw HTML\n"
				"    -e, --extract          Extract specified metadata\n"
				"    -a, --accept           Accept all CriticMarkup changes\n"
				"    -r, --reject           Reject all CriticMarkup changes\n"
				"\n"
				"    --smart, --nosmart     Toggle smart typography\n"
				"    --notes, --nonotes     Toggle footnotes\n"
				"    --labels, --nolabels   Disable id attributes for headers\n"
				"    --mask, --nomask       Mask email addresses in HTML\n"
				
				"\nAvailable FORMATs: html(default), latex, beamer, memoir, odf, opml\n\n\n"
				);
				return(EXIT_SUCCESS);
			
			case 't':	/* output format */
				if (strcmp(optarg, "text") == 0)
					output_format = TEXT_FORMAT;
				else if (strcmp(optarg, "html") == 0)
					output_format = HTML_FORMAT;
				else if (strcmp(optarg, "latex") == 0)
					output_format = LATEX_FORMAT;
				else if (strcmp(optarg, "memoir") == 0)
					output_format = MEMOIR_FORMAT;
				else if (strcmp(optarg, "beamer") == 0)
					output_format = BEAMER_FORMAT;
				else if (strcmp(optarg, "opml") == 0)
					output_format = OPML_FORMAT;
				else if (strcmp(optarg, "odf") == 0)
					output_format = ODF_FORMAT;
				else {
					/* no valid format specified */
					fprintf(stderr, "%s: Unknown output format '%s'\n",argv[0], optarg);
					exit(EXIT_FAILURE);
				}
				break;
			
			case 'f':	/* full doc */
				extensions = extensions | EXT_COMPLETE;
				break;
			
			case 'e':	/* extract metadata */
				target_meta_key = strdup(optarg);
				break;
			
			case '?':	/* long handles */
				break;
				
			case 'a':	/* Accept CriticMarkup changes */
				extensions = extensions | EXT_CRITIC_ACCEPT;
				break;
			
			case 'r':	/* Reject CriticMarkup changes */
				extensions = extensions | EXT_CRITIC_REJECT;
				break;
			
			default:
			fprintf(stderr,"Error parsing options.\n");
			abort();
		}
	}	
	
	/* Compatibility mode emulates the behavior of Markdown.pl */
	if (compatibility_flag) {
		extensions = 0x000000;
		extensions = extensions | EXT_COMPATIBILITY | EXT_NO_LABELS | EXT_OBFUSCATE;
	}

	/* apply extensions from long options*/
	if (complete_flag)
		extensions = extensions | EXT_COMPLETE;
	
	if (notes_flag)
		extensions = extensions | EXT_NOTES;
	
	if (no_notes_flag)
		extensions &= ~EXT_NOTES;

	if (typography_flag)
		extensions = extensions | EXT_SMART;

	if (no_typography_flag)
		extensions &= ~EXT_SMART;

	if (label_flag)
		extensions &= ~EXT_NO_LABELS;

	if (no_label_flag)
		extensions = extensions | EXT_NO_LABELS;
	
	if (obfuscate_flag)
		extensions = extensions | EXT_OBFUSCATE;

	if (no_obfuscate_flag)
		extensions &= ~EXT_OBFUSCATE;

	if (process_html_flag)
		extensions = extensions | EXT_PROCESS_HTML;

	/* fix numbering to account for options */
	argc -= optind;
	argv += optind;
	
	/* We expect argc and argv to still point just one below the start of remaining args */
	argc++;
	argv--;
	
	/* any filenames */
	numargs = argc -1;

	if (batch_flag && (numargs != 0)) {
		/* we have multiple file names -- handle individually */
		
		for (i = 0; i < numargs; i++) {
			inputbuf = g_string_new("");
			
			/* Read file */
			if ((input = fopen(argv[i+1], "r")) == NULL ) {
				perror(argv[i+1]);
				g_string_free(inputbuf, true);
				g_string_free(filename, true);
				exit(EXIT_FAILURE);
			}
			
			while ((curchar = fgetc(input)) != EOF)
				g_string_append_c(inputbuf, curchar);
			fclose(input);
			
			/* extract metadata */
			if (target_meta_key) {
				if (has_metadata(inputbuf->str, extensions)) {
					fprintf(stdout, "+ meta\n");
				} else {
					fprintf(stdout, "- meta\n");
				}
				
				out = extract_metadata_value(inputbuf->str, extensions, target_meta_key);
				if (out != NULL)
					fprintf(stdout, "%s\n", out);
				free(out);
				g_string_free(inputbuf, true);
				free(target_meta_key);
				return(EXIT_SUCCESS);
			}
			
			out = markdown_to_string(inputbuf->str,  extensions, output_format);
			
			g_string_free(inputbuf, true);
			
			/* set up for output */
			temp = argv[i+1];	/* get current filename */
			if (strrchr(temp,'.') != NULL) {
				long count = strrchr(temp,'.') - temp;
				if (count != 0) {
					/* truncate string at "." */
					temp[count] = '\0';
				}
			}
			
			filename = g_string_new(temp);
			
			if (output_format == TEXT_FORMAT) {
				g_string_append(filename,".txt");
			} else if (output_format == HTML_FORMAT) {
				g_string_append(filename,".html");
			} else if (output_format == LATEX_FORMAT) {
				g_string_append(filename,".tex");
			} else if (output_format == BEAMER_FORMAT) {
				g_string_append(filename,".tex");
			} else if (output_format == MEMOIR_FORMAT) {
				g_string_append(filename,".tex");
			} else if (output_format == ODF_FORMAT) {
				g_string_append(filename,".fodt");
			} else if (output_format == OPML_FORMAT) {
				g_string_append(filename,".opml");
			} else {
				/* default extension -- in this case we only have 1 */
				g_string_append(filename,".txt");
			}
			
			if (!(output = fopen(filename->str, "w"))) {
				perror(filename->str);
			} else {
				fprintf(output, "%s\n",out);
				fclose(output);
			}
			
			g_string_free(filename,true);
			
			if (out != NULL)
				free(out);
		}
	} else {
		/* get input from stdin or concat all files */
		inputbuf = g_string_new("");
		
		if (numargs == 0) {
			/* get stdin */
			while ((curchar = fgetc(stdin)) != EOF)
				g_string_append_c(inputbuf, curchar);
			fclose(stdin);
		} else {
			/* get files */
			for (i = 0; i < numargs; i++) {
				if ((input = fopen(argv[i+1], "r")) == NULL ) {
					perror(argv[i+1]);
					g_string_free(inputbuf, true);
					g_string_free(filename, true);
					exit(EXIT_FAILURE);
				}
				
				while ((curchar = fgetc(input)) != EOF)
					g_string_append_c(inputbuf, curchar);
				fclose(input);
			}
		}
		
		/* extract metadata */
		if (target_meta_key) {
				if (has_metadata(inputbuf->str, extensions)) {
					fprintf(stdout, "+ meta\n");
				} else {
					fprintf(stdout, "- meta\n");
				}
			out = extract_metadata_value(inputbuf->str, extensions, target_meta_key);
			if (out != NULL)
				fprintf(stdout, "%s\n", out);
			free(out);
			g_string_free(inputbuf, true);
			free(target_meta_key);
			return(EXIT_SUCCESS);
		}

		out = markdown_to_string(inputbuf->str, extensions, output_format);
		
		g_string_free(inputbuf, true);
		
		/* did we specify an output filename; "-" equals stdout */
		if ((filename == NULL) || (strcmp(filename->str, "-") == 0)) {
			output = stdout;
		} else if (!(output = fopen(filename->str, "w"))) {
			perror(filename->str);
			if (out != NULL)
				free(out);
			g_string_free(filename, true);
			return 1;
		}
		
		fprintf(output, "%s\n",out);
		fclose(output);
		
		g_string_free(filename, false);
		
		if (out != NULL)
			free(out);
	}
	
	return(EXIT_SUCCESS);
}



#endif
